var st = Object.defineProperty;
var ut = (t, e, n) => e in t ? st(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var C = (t, e, n) => ut(t, typeof e != "symbol" ? e + "" : e, n);
function Je(t, e) {
  return { handler: t, config: e };
}
Je.withOptions = function(t, e = () => ({})) {
  function n(r) {
    return { handler: t(r), config: e(r) };
  }
  return n.__isOptionsFunction = !0, n;
};
var ct = Je;
const lt = (t) => {
  switch (t) {
    // Sizing & Spacing
    case "p":
      return {
        type: "spacing",
        key: "padding",
        props: ["padding"]
      };
    case "pt":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingTop"]
      };
    case "pb":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingBottom"]
      };
    case "pl":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingLeft"]
      };
    case "ps":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingInlineStart"]
      };
    case "pr":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingRight"]
      };
    case "pe":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingInlineEnd"]
      };
    case "px":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingInline"]
      };
    case "py":
      return {
        type: "spacing",
        key: "padding",
        props: ["paddingBlock"]
      };
    case "m":
      return {
        type: "spacing",
        key: "margin",
        props: ["margin"]
      };
    case "mt":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginTop"]
      };
    case "mb":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginBottom"]
      };
    case "ml":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginLeft"]
      };
    case "ms":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginInlineStart"]
      };
    case "mr":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginRight"]
      };
    case "me":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginInlineEnd"]
      };
    case "mx":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginInline"]
      };
    case "my":
      return {
        type: "spacing",
        key: "margin",
        props: ["marginBlock"]
      };
    case "inset":
      return {
        type: "spacing",
        key: "inset",
        props: ["inset"]
      };
    case "inset-x":
      return {
        type: "spacing",
        key: "inset",
        props: ["insetInline"]
      };
    case "inset-y":
      return {
        type: "spacing",
        key: "inset",
        props: ["insetBlock"]
      };
    case "start":
      return {
        type: "spacing",
        key: "inset",
        props: ["insetInlineStart"]
      };
    case "end":
      return {
        type: "spacing",
        key: "inset",
        props: ["insetInlineEnd"]
      };
    case "top":
      return {
        type: "spacing",
        key: "inset",
        props: ["top"]
      };
    case "left":
      return {
        type: "spacing",
        key: "inset",
        props: ["left"]
      };
    case "right":
      return {
        type: "spacing",
        key: "inset",
        props: ["right"]
      };
    case "bottom":
      return {
        type: "spacing",
        key: "inset",
        props: ["bottom"]
      };
    case "gap":
      return {
        type: "spacing",
        key: "gap",
        props: ["gap"]
      };
    case "gap-x":
      return {
        type: "spacing",
        key: "gap",
        props: ["columnGap"]
      };
    case "gap-y":
      return {
        type: "spacing",
        key: "gap",
        props: ["rowGap"]
      };
    case "w":
      return {
        type: "spacing",
        key: "width",
        props: ["width"]
      };
    case "h":
      return {
        type: "spacing",
        key: "height",
        props: ["height"]
      };
    case "size":
      return {
        type: "spacing",
        key: "size",
        props: ["width", "height"]
      };
    case "min-w":
      return {
        type: "spacing",
        key: "minWidth",
        props: ["minWidth"]
      };
    case "min-h":
      return {
        type: "spacing",
        key: "minHeight",
        props: ["minHeight"]
      };
    case "max-w":
      return {
        type: "spacing",
        key: "maxWidth",
        props: ["maxWidth"]
      };
    case "max-h":
      return {
        type: "spacing",
        key: "maxHeight",
        props: ["maxHeight"]
      };
    case "scroll-m":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMargin"]
      };
    case "scroll-mx":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginInline"]
      };
    case "scroll-my":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginBlock"]
      };
    case "scroll-ms":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginInlineStart"]
      };
    case "scroll-me":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginInlineEnd"]
      };
    case "scroll-mt":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginTop"]
      };
    case "scroll-mb":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginBottom"]
      };
    case "scroll-ml":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginLeft"]
      };
    case "scroll-mr":
      return {
        type: "spacing",
        key: "scrollMargin",
        props: ["scrollMarginRight"]
      };
    case "scroll-p":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPadding"]
      };
    case "scroll-px":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingInline"]
      };
    case "scroll-py":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingBlock"]
      };
    case "scroll-ps":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingInlineStart"]
      };
    case "scroll-pe":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingInlineEnd"]
      };
    case "scroll-pt":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingTop"]
      };
    case "scroll-pb":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingBottom"]
      };
    case "scroll-pl":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingLeft"]
      };
    case "scroll-pr":
      return {
        type: "spacing",
        key: "scrollPadding",
        props: ["scrollPaddingRight"]
      };
    case "translate":
      return {
        type: "spacing",
        key: "translate",
        props: [
          "--tw-translate-x",
          "--tw-translate-y",
          { translate: "var(--tw-translate-x) var(--tw-translate-y)" }
        ]
      };
    case "translate-x":
      return {
        type: "spacing",
        key: "translate",
        props: [
          "--tw-translate-x",
          { translate: "var(--tw-translate-x) var(--tw-translate-y)" }
        ]
      };
    case "translate-y":
      return {
        type: "spacing",
        key: "translate",
        props: [
          "--tw-translate-y",
          { translate: "var(--tw-translate-x) var(--tw-translate-y)" }
        ]
      };
    case "underline-offset":
      return {
        type: "regular",
        key: "textUnderlineOffset",
        props: ["textUnderlineOffset"]
      };
    // Border & Stroke
    case "stroke":
      return {
        type: "regular",
        key: "strokeWidth",
        props: ["strokeWidth"]
      };
    case "border":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderWidth"]
      };
    case "border-t":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderTopWidth"]
      };
    case "border-b":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderBottomWidth"]
      };
    case "border-l":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderLeftWidth"]
      };
    case "border-s":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderInlineStartWidth"]
      };
    case "border-r":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderRightWidth"]
      };
    case "border-e":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderInlineEndWidth"]
      };
    case "border-x":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderInlineWidth"]
      };
    case "border-y":
      return {
        type: "regular",
        key: "borderWidth",
        props: ["borderBlockWidth"]
      };
    case "decoration":
      return {
        type: "regular",
        key: "textDecorationThickness",
        props: ["textDecorationThickness"]
      };
    // Border Radius
    case "rounded":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderRadius"]
      };
    case "rounded-s":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderStartStartRadius", "borderEndStartRadius"]
      };
    case "rounded-ss":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderStartStartRadius"]
      };
    case "rounded-se":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderStartEndRadius"]
      };
    case "rounded-e":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderStartEndRadius", "borderEndEndRadius"]
      };
    case "rounded-ee":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderEndEndRadius"]
      };
    case "rounded-es":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderEndStartRadius"]
      };
    case "rounded-t":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderTopLeftRadius", "borderTopRightRadius"]
      };
    case "rounded-r":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderTopRightRadius", "borderBottomRightRadius"]
      };
    case "rounded-b":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderBottomLeftRadius", "borderBottomRightRadius"]
      };
    case "rounded-l":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderTopLeftRadius", "borderBottomLeftRadius"]
      };
    case "rounded-tl":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderTopLeftRadius"]
      };
    case "rounded-tr":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderTopRightRadius"]
      };
    case "rounded-bl":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderBottomLeftRadius"]
      };
    case "rounded-br":
      return {
        type: "regular",
        key: "borderRadius",
        props: ["borderBottomRightRadius"]
      };
    case "leading":
      return {
        type: "regular",
        key: "lineHeight",
        props: ["lineHeight"]
      };
    case "tracking":
      return {
        type: "regular",
        key: "letterSpacing",
        props: ["letterSpacing"]
      };
    // Type
    case "text":
      return {
        type: "fontSize",
        key: "fontSize",
        props: ["fontSize"]
      };
    default:
      return null;
  }
}, fe = {
  error() {
    console.log("\x1B[31m", ...arguments, "\x1B[0m");
  },
  warn() {
    console.log("\x1B[33m", ...arguments, "\x1B[0m");
  },
  info() {
    console.log("\x1B[34m", ...arguments, "\x1B[0m");
  },
  log() {
    console.log("\x1B[90m", ...arguments, "\x1B[0m");
  }
};
class Se extends Error {
  constructor(n, r, o, i) {
    super(n);
    C(this, "sourceStart");
    C(this, "sourceEnd");
    C(this, "parserState");
    this.name = "ParseError", this.sourceStart = r, this.sourceEnd = o, this.parserState = i;
  }
}
class J extends Se {
  constructor(n, r, o, i, s) {
    super(n, r, o, i);
    C(this, "token");
    this.token = s;
  }
}
const H = { UnexpectedNewLineInString: "Unexpected newline while consuming a string token.", UnexpectedEOFInString: "Unexpected EOF while consuming a string token.", UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.", UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.", UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.", UnexpectedCharacterInURL: "Unexpected character while consuming a url token.", InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.", InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"' };
function j(...t) {
  let e = "";
  for (let n = 0; n < t.length; n++) e += t[n][1];
  return e;
}
const ee = 13, D = 45, te = 10, ne = 43, _ = 65533;
function dt(t) {
  return t.source.codePointAt(t.cursor) === 60 && t.source.codePointAt(t.cursor + 1) === 33 && t.source.codePointAt(t.cursor + 2) === D && t.source.codePointAt(t.cursor + 3) === D;
}
function R(t) {
  return t >= 48 && t <= 57;
}
function pt(t) {
  return t >= 65 && t <= 90;
}
function ft(t) {
  return t >= 97 && t <= 122;
}
function K(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function vt(t) {
  return ft(t) || pt(t);
}
function re(t) {
  return vt(t) || gt(t) || t === 95;
}
function Me(t) {
  return re(t) || R(t) || t === D;
}
function gt(t) {
  return t === 183 || t === 8204 || t === 8205 || t === 8255 || t === 8256 || t === 8204 || 192 <= t && t <= 214 || 216 <= t && t <= 246 || 248 <= t && t <= 893 || 895 <= t && t <= 8191 || 8304 <= t && t <= 8591 || 11264 <= t && t <= 12271 || 12289 <= t && t <= 55295 || 63744 <= t && t <= 64975 || 65008 <= t && t <= 65533 || t === 0 || !!oe(t) || t >= 65536;
}
function Pe(t) {
  return t === te || t === ee || t === 12;
}
function Q(t) {
  return t === 32 || t === te || t === 9 || t === ee || t === 12;
}
function oe(t) {
  return t >= 55296 && t <= 57343;
}
function ce(t) {
  return t.source.codePointAt(t.cursor) === 92 && !Pe(t.source.codePointAt(t.cursor + 1) ?? -1);
}
function ke(t, e) {
  return e.source.codePointAt(e.cursor) === D ? e.source.codePointAt(e.cursor + 1) === D || !!re(e.source.codePointAt(e.cursor + 1) ?? -1) || e.source.codePointAt(e.cursor + 1) === 92 && !Pe(e.source.codePointAt(e.cursor + 2) ?? -1) : !!re(e.source.codePointAt(e.cursor) ?? -1) || ce(e);
}
function $e(t) {
  return t.source.codePointAt(t.cursor) === ne || t.source.codePointAt(t.cursor) === D ? !!R(t.source.codePointAt(t.cursor + 1) ?? -1) || t.source.codePointAt(t.cursor + 1) === 46 && R(t.source.codePointAt(t.cursor + 2) ?? -1) : t.source.codePointAt(t.cursor) === 46 ? R(t.source.codePointAt(t.cursor + 1) ?? -1) : R(t.source.codePointAt(t.cursor) ?? -1);
}
function mt(t) {
  return t.source.codePointAt(t.cursor) === 47 && t.source.codePointAt(t.cursor + 1) === 42;
}
function ht(t) {
  return t.source.codePointAt(t.cursor) === D && t.source.codePointAt(t.cursor + 1) === D && t.source.codePointAt(t.cursor + 2) === 62;
}
var a, l, be;
function Ct(t) {
  switch (t) {
    case a.OpenParen:
      return a.CloseParen;
    case a.CloseParen:
      return a.OpenParen;
    case a.OpenCurly:
      return a.CloseCurly;
    case a.CloseCurly:
      return a.OpenCurly;
    case a.OpenSquare:
      return a.CloseSquare;
    case a.CloseSquare:
      return a.OpenSquare;
    default:
      return null;
  }
}
function yt(t) {
  switch (t[0]) {
    case a.OpenParen:
      return [a.CloseParen, ")", -1, -1, void 0];
    case a.CloseParen:
      return [a.OpenParen, "(", -1, -1, void 0];
    case a.OpenCurly:
      return [a.CloseCurly, "}", -1, -1, void 0];
    case a.CloseCurly:
      return [a.OpenCurly, "{", -1, -1, void 0];
    case a.OpenSquare:
      return [a.CloseSquare, "]", -1, -1, void 0];
    case a.CloseSquare:
      return [a.OpenSquare, "[", -1, -1, void 0];
    default:
      return null;
  }
}
function Et(t, e) {
  for (e.advanceCodePoint(2); ; ) {
    const n = e.readCodePoint();
    if (n === void 0) {
      const r = [a.Comment, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0];
      return t.onParseError(new J(H.UnexpectedEOFInComment, e.representationStart, e.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"], r)), r;
    }
    if (n === 42 && e.source.codePointAt(e.cursor) !== void 0 && e.source.codePointAt(e.cursor) === 47) {
      e.advanceCodePoint();
      break;
    }
  }
  return [a.Comment, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0];
}
function Ae(t, e) {
  const n = e.readCodePoint();
  if (n === void 0) return t.onParseError(new Se(H.UnexpectedEOFInEscapedCodePoint, e.representationStart, e.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), _;
  if (K(n)) {
    const r = [n];
    let o;
    for (; (o = e.source.codePointAt(e.cursor)) !== void 0 && K(o) && r.length < 6; ) r.push(o), e.advanceCodePoint();
    Q(e.source.codePointAt(e.cursor) ?? -1) && (e.source.codePointAt(e.cursor) === ee && e.source.codePointAt(e.cursor + 1) === te && e.advanceCodePoint(), e.advanceCodePoint());
    const i = parseInt(String.fromCodePoint(...r), 16);
    return i === 0 || oe(i) || i > 1114111 ? _ : i;
  }
  return n === 0 || oe(n) ? _ : n;
}
function De(t, e) {
  const n = [];
  for (; ; ) {
    const r = e.source.codePointAt(e.cursor) ?? -1;
    if (r === 0 || oe(r)) n.push(_), e.advanceCodePoint(+(r > 65535) + 1);
    else if (Me(r)) n.push(r), e.advanceCodePoint(+(r > 65535) + 1);
    else {
      if (!ce(e)) return n;
      e.advanceCodePoint(), n.push(Ae(t, e));
    }
  }
}
function Pt(t, e) {
  e.advanceCodePoint();
  const n = e.source.codePointAt(e.cursor);
  if (n !== void 0 && (Me(n) || ce(e))) {
    let r = be.Unrestricted;
    ke(0, e) && (r = be.ID);
    const o = De(t, e);
    return [a.Hash, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: String.fromCodePoint(...o), type: r }];
  }
  return [a.Delim, "#", e.representationStart, e.representationEnd, { value: "#" }];
}
function kt(t, e) {
  let n = l.Integer;
  for (e.source.codePointAt(e.cursor) !== ne && e.source.codePointAt(e.cursor) !== D || e.advanceCodePoint(); R(e.source.codePointAt(e.cursor) ?? -1); ) e.advanceCodePoint();
  if (e.source.codePointAt(e.cursor) === 46 && R(e.source.codePointAt(e.cursor + 1) ?? -1)) for (e.advanceCodePoint(2), n = l.Number; R(e.source.codePointAt(e.cursor) ?? -1); ) e.advanceCodePoint();
  if (e.source.codePointAt(e.cursor) === 101 || e.source.codePointAt(e.cursor) === 69) {
    if (R(e.source.codePointAt(e.cursor + 1) ?? -1)) e.advanceCodePoint(2);
    else {
      if (e.source.codePointAt(e.cursor + 1) !== D && e.source.codePointAt(e.cursor + 1) !== ne || !R(e.source.codePointAt(e.cursor + 2) ?? -1)) return n;
      e.advanceCodePoint(3);
    }
    for (n = l.Number; R(e.source.codePointAt(e.cursor) ?? -1); ) e.advanceCodePoint();
  }
  return n;
}
function we(t, e) {
  let n;
  {
    const i = e.source.codePointAt(e.cursor);
    i === D ? n = "-" : i === ne && (n = "+");
  }
  const r = kt(0, e), o = parseFloat(e.source.slice(e.representationStart, e.representationEnd + 1));
  if (ke(0, e)) {
    const i = De(t, e);
    return [a.Dimension, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: o, signCharacter: n, type: r, unit: String.fromCodePoint(...i) }];
  }
  return e.source.codePointAt(e.cursor) === 37 ? (e.advanceCodePoint(), [a.Percentage, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: o, signCharacter: n }]) : [a.Number, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: o, signCharacter: n, type: r }];
}
function bt(t) {
  for (; Q(t.source.codePointAt(t.cursor) ?? -1); ) t.advanceCodePoint();
  return [a.Whitespace, t.source.slice(t.representationStart, t.representationEnd + 1), t.representationStart, t.representationEnd, void 0];
}
(function(t) {
  t.Comment = "comment", t.AtKeyword = "at-keyword-token", t.BadString = "bad-string-token", t.BadURL = "bad-url-token", t.CDC = "CDC-token", t.CDO = "CDO-token", t.Colon = "colon-token", t.Comma = "comma-token", t.Delim = "delim-token", t.Dimension = "dimension-token", t.EOF = "EOF-token", t.Function = "function-token", t.Hash = "hash-token", t.Ident = "ident-token", t.Number = "number-token", t.Percentage = "percentage-token", t.Semicolon = "semicolon-token", t.String = "string-token", t.URL = "url-token", t.Whitespace = "whitespace-token", t.OpenParen = "(-token", t.CloseParen = ")-token", t.OpenSquare = "[-token", t.CloseSquare = "]-token", t.OpenCurly = "{-token", t.CloseCurly = "}-token", t.UnicodeRange = "unicode-range-token";
})(a || (a = {})), function(t) {
  t.Integer = "integer", t.Number = "number";
}(l || (l = {})), function(t) {
  t.Unrestricted = "unrestricted", t.ID = "id";
}(be || (be = {}));
class St {
  constructor(e) {
    C(this, "cursor", 0);
    C(this, "source", "");
    C(this, "representationStart", 0);
    C(this, "representationEnd", -1);
    this.source = e;
  }
  advanceCodePoint(e = 1) {
    this.cursor = this.cursor + e, this.representationEnd = this.cursor - 1;
  }
  readCodePoint() {
    const e = this.source.codePointAt(this.cursor);
    if (e !== void 0) return this.cursor = this.cursor + 1, this.representationEnd = this.cursor - 1, e;
  }
  unreadCodePoint(e = 1) {
    this.cursor = this.cursor - e, this.representationEnd = this.cursor - 1;
  }
  resetRepresentation() {
    this.representationStart = this.cursor, this.representationEnd = -1;
  }
}
function At(t, e) {
  let n = "";
  const r = e.readCodePoint();
  for (; ; ) {
    const o = e.readCodePoint();
    if (o === void 0) {
      const i = [a.String, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }];
      return t.onParseError(new J(H.UnexpectedEOFInString, e.representationStart, e.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"], i)), i;
    }
    if (Pe(o)) {
      e.unreadCodePoint();
      const i = [a.BadString, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0];
      return t.onParseError(new J(H.UnexpectedNewLineInString, e.representationStart, e.source.codePointAt(e.cursor) === ee && e.source.codePointAt(e.cursor + 1) === te ? e.representationEnd + 2 : e.representationEnd + 1, ["4.3.5. Consume a string token", "Unexpected newline"], i)), i;
    }
    if (o === r) return [a.String, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }];
    if (o !== 92) o === 0 || oe(o) ? n += String.fromCodePoint(_) : n += String.fromCodePoint(o);
    else {
      if (e.source.codePointAt(e.cursor) === void 0) continue;
      if (Pe(e.source.codePointAt(e.cursor) ?? -1)) {
        e.source.codePointAt(e.cursor) === ee && e.source.codePointAt(e.cursor + 1) === te && e.advanceCodePoint(), e.advanceCodePoint();
        continue;
      }
      n += String.fromCodePoint(Ae(t, e));
    }
  }
}
function Dt(t) {
  return !(t.length !== 3 || t[0] !== 117 && t[0] !== 85 || t[1] !== 114 && t[1] !== 82 || t[2] !== 108 && t[2] !== 76);
}
function Ie(t, e) {
  for (; ; ) {
    const n = e.source.codePointAt(e.cursor);
    if (n === void 0) return;
    if (n === 41) return void e.advanceCodePoint();
    ce(e) ? (e.advanceCodePoint(), Ae(t, e)) : e.advanceCodePoint();
  }
}
function Bt(t, e) {
  for (; Q(e.source.codePointAt(e.cursor) ?? -1); ) e.advanceCodePoint();
  let n = "";
  for (; ; ) {
    if (e.source.codePointAt(e.cursor) === void 0) {
      const i = [a.URL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }];
      return t.onParseError(new J(H.UnexpectedEOFInURL, e.representationStart, e.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"], i)), i;
    }
    if (e.source.codePointAt(e.cursor) === 41) return e.advanceCodePoint(), [a.URL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }];
    if (Q(e.source.codePointAt(e.cursor) ?? -1)) {
      for (e.advanceCodePoint(); Q(e.source.codePointAt(e.cursor) ?? -1); ) e.advanceCodePoint();
      if (e.source.codePointAt(e.cursor) === void 0) {
        const i = [a.URL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }];
        return t.onParseError(new J(H.UnexpectedEOFInURL, e.representationStart, e.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"], i)), i;
      }
      return e.source.codePointAt(e.cursor) === 41 ? (e.advanceCodePoint(), [a.URL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: n }]) : (Ie(t, e), [a.BadURL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0]);
    }
    const o = e.source.codePointAt(e.cursor);
    if (o === 34 || o === 39 || o === 40 || (r = o ?? -1) === 11 || r === 127 || 0 <= r && r <= 8 || 14 <= r && r <= 31) {
      Ie(t, e);
      const i = [a.BadURL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0];
      return t.onParseError(new J(H.UnexpectedCharacterInURL, e.representationStart, e.representationEnd, ["4.3.6. Consume a url token", `Unexpected U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point`], i)), i;
    }
    if (o === 92) {
      if (ce(e)) {
        e.advanceCodePoint(), n += String.fromCodePoint(Ae(t, e));
        continue;
      }
      Ie(t, e);
      const i = [a.BadURL, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, void 0];
      return t.onParseError(new J(H.InvalidEscapeSequenceInURL, e.representationStart, e.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], i)), i;
    }
    e.source.codePointAt(e.cursor) === 0 || oe(e.source.codePointAt(e.cursor) ?? -1) ? (n += String.fromCodePoint(_), e.advanceCodePoint()) : (n += e.source[e.cursor], e.advanceCodePoint());
  }
  var r;
}
function xe(t, e) {
  const n = De(t, e);
  if (e.source.codePointAt(e.cursor) !== 40) return [a.Ident, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: String.fromCodePoint(...n) }];
  if (Dt(n)) {
    e.advanceCodePoint();
    let r = 0;
    for (; ; ) {
      const o = Q(e.source.codePointAt(e.cursor) ?? -1), i = Q(e.source.codePointAt(e.cursor + 1) ?? -1);
      if (o && i) {
        r += 1, e.advanceCodePoint(1);
        continue;
      }
      const s = o ? e.source.codePointAt(e.cursor + 1) : e.source.codePointAt(e.cursor);
      if (s === 34 || s === 39) return r > 0 && e.unreadCodePoint(r), [a.Function, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: String.fromCodePoint(...n) }];
      break;
    }
    return Bt(t, e);
  }
  return e.advanceCodePoint(), [a.Function, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { value: String.fromCodePoint(...n) }];
}
function Ft(t) {
  return !(t.source.codePointAt(t.cursor) !== 117 && t.source.codePointAt(t.cursor) !== 85 || t.source.codePointAt(t.cursor + 1) !== ne || t.source.codePointAt(t.cursor + 2) !== 63 && !K(t.source.codePointAt(t.cursor + 2) ?? -1));
}
function Nt(t, e) {
  e.advanceCodePoint(2);
  const n = [], r = [];
  let o;
  for (; (o = e.source.codePointAt(e.cursor)) !== void 0 && n.length < 6 && K(o); ) n.push(o), e.advanceCodePoint();
  for (; (o = e.source.codePointAt(e.cursor)) !== void 0 && n.length < 6 && o === 63; ) r.length === 0 && r.push(...n), n.push(48), r.push(70), e.advanceCodePoint();
  if (!r.length && e.source.codePointAt(e.cursor) === D && K(e.source.codePointAt(e.cursor + 1) ?? -1)) for (e.advanceCodePoint(); (o = e.source.codePointAt(e.cursor)) !== void 0 && r.length < 6 && K(o); ) r.push(o), e.advanceCodePoint();
  if (!r.length) {
    const u = parseInt(String.fromCodePoint(...n), 16);
    return [a.UnicodeRange, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { startOfRange: u, endOfRange: u }];
  }
  const i = parseInt(String.fromCodePoint(...n), 16), s = parseInt(String.fromCodePoint(...r), 16);
  return [a.UnicodeRange, e.source.slice(e.representationStart, e.representationEnd + 1), e.representationStart, e.representationEnd, { startOfRange: i, endOfRange: s }];
}
function wt(t, e) {
  const n = It(t), r = [];
  for (; !n.endOfFile(); ) r.push(n.nextToken());
  return r.push(n.nextToken()), r;
}
function It(t, e) {
  const n = t.css.valueOf(), r = t.unicodeRangesAllowed ?? !1, o = new St(n), i = { onParseError: xt };
  return { nextToken: function() {
    o.resetRepresentation();
    const u = o.source.codePointAt(o.cursor);
    if (u === void 0) return [a.EOF, "", -1, -1, void 0];
    if (u === 47 && mt(o)) return Et(i, o);
    if (r && (u === 117 || u === 85) && Ft(o)) return Nt(0, o);
    if (re(u)) return xe(i, o);
    if (R(u)) return we(i, o);
    switch (u) {
      case 44:
        return o.advanceCodePoint(), [a.Comma, ",", o.representationStart, o.representationEnd, void 0];
      case 58:
        return o.advanceCodePoint(), [a.Colon, ":", o.representationStart, o.representationEnd, void 0];
      case 59:
        return o.advanceCodePoint(), [a.Semicolon, ";", o.representationStart, o.representationEnd, void 0];
      case 40:
        return o.advanceCodePoint(), [a.OpenParen, "(", o.representationStart, o.representationEnd, void 0];
      case 41:
        return o.advanceCodePoint(), [a.CloseParen, ")", o.representationStart, o.representationEnd, void 0];
      case 91:
        return o.advanceCodePoint(), [a.OpenSquare, "[", o.representationStart, o.representationEnd, void 0];
      case 93:
        return o.advanceCodePoint(), [a.CloseSquare, "]", o.representationStart, o.representationEnd, void 0];
      case 123:
        return o.advanceCodePoint(), [a.OpenCurly, "{", o.representationStart, o.representationEnd, void 0];
      case 125:
        return o.advanceCodePoint(), [a.CloseCurly, "}", o.representationStart, o.representationEnd, void 0];
      case 39:
      case 34:
        return At(i, o);
      case 35:
        return Pt(i, o);
      case ne:
      case 46:
        return $e(o) ? we(i, o) : (o.advanceCodePoint(), [a.Delim, o.source[o.representationStart], o.representationStart, o.representationEnd, { value: o.source[o.representationStart] }]);
      case te:
      case ee:
      case 12:
      case 9:
      case 32:
        return bt(o);
      case D:
        return $e(o) ? we(i, o) : ht(o) ? (o.advanceCodePoint(3), [a.CDC, "-->", o.representationStart, o.representationEnd, void 0]) : ke(0, o) ? xe(i, o) : (o.advanceCodePoint(), [a.Delim, "-", o.representationStart, o.representationEnd, { value: "-" }]);
      case 60:
        return dt(o) ? (o.advanceCodePoint(4), [a.CDO, "<!--", o.representationStart, o.representationEnd, void 0]) : (o.advanceCodePoint(), [a.Delim, "<", o.representationStart, o.representationEnd, { value: "<" }]);
      case 64:
        if (o.advanceCodePoint(), ke(0, o)) {
          const c = De(i, o);
          return [a.AtKeyword, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, { value: String.fromCodePoint(...c) }];
        }
        return [a.Delim, "@", o.representationStart, o.representationEnd, { value: "@" }];
      case 92: {
        if (ce(o)) return xe(i, o);
        o.advanceCodePoint();
        const c = [a.Delim, "\\", o.representationStart, o.representationEnd, { value: "\\" }];
        return i.onParseError(new J(H.InvalidEscapeSequenceAfterBackslash, o.representationStart, o.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], c)), c;
      }
    }
    return o.advanceCodePoint(), [a.Delim, o.source[o.representationStart], o.representationStart, o.representationEnd, { value: o.source[o.representationStart] }];
  }, endOfFile: function() {
    return o.source.codePointAt(o.cursor) === void 0;
  } };
}
function xt() {
}
function Tt(t, e) {
  const n = [];
  for (const u of e) n.push(u.codePointAt(0));
  const r = Ot(n);
  r[0] === 101 && Ee(r, 0, r[0]);
  const o = String.fromCodePoint(...r), i = t[4].signCharacter === "+" ? t[4].signCharacter : "", s = t[4].value.toString();
  t[1] = `${i}${s}${o}`, t[4].unit = e;
}
function Ot(t) {
  let e = 0;
  t[0] === D && t[1] === D ? e = 2 : t[0] === D && t[1] ? (e = 2, re(t[1]) || (e += Ee(t, 1, t[1]))) : re(t[0]) ? e = 1 : (e = 1, e += Ee(t, 0, t[0]));
  for (let n = e; n < t.length; n++) Me(t[n]) || (n += Ee(t, n, t[n]));
  return t;
}
function Ee(t, e, n) {
  const r = n.toString(16), o = [];
  for (const s of r) o.push(s.codePointAt(0));
  const i = t[e + 1];
  return e === t.length - 1 || i && K(i) ? (t.splice(e, 1, 92, ...o, 32), 1 + o.length) : (t.splice(e, 1, 92, ...o), o.length);
}
const Mt = Object.values(a);
function Ye(t) {
  return !!Array.isArray(t) && !(t.length < 4) && !!Mt.includes(t[0]) && typeof t[1] == "string" && typeof t[2] == "number" && typeof t[3] == "number";
}
function b(t) {
  if (!t) return !1;
  switch (t[0]) {
    case a.Dimension:
    case a.Number:
    case a.Percentage:
      return !0;
    default:
      return !1;
  }
}
function Ze(t) {
  if (!t) return !1;
  switch (t[0]) {
    case a.Whitespace:
    case a.Comment:
      return !0;
    default:
      return !1;
  }
}
function ie(t) {
  return !!t && t[0] === a.Comma;
}
function Ke(t) {
  return !!t && t[0] === a.Comment;
}
function qe(t) {
  return !!t && t[0] === a.Delim;
}
function y(t) {
  return !!t && t[0] === a.Dimension;
}
function Y(t) {
  return !!t && t[0] === a.EOF;
}
function Rt(t) {
  return !!t && t[0] === a.Function;
}
function ve(t) {
  return !!t && t[0] === a.Ident;
}
function g(t) {
  return !!t && t[0] === a.Number;
}
function P(t) {
  return !!t && t[0] === a.Percentage;
}
function Re(t) {
  return !!t && t[0] === a.Whitespace;
}
function Qe(t) {
  return !!t && t[0] === a.OpenParen;
}
function Ut(t) {
  return !!t && t[0] === a.CloseParen;
}
function Wt(t) {
  return !!t && t[0] === a.OpenSquare;
}
function Lt(t) {
  return !!t && t[0] === a.OpenCurly;
}
var U;
function Xe(t) {
  let e = t.slice();
  return (n, r, o) => {
    let i = -1;
    for (let s = e.indexOf(r); s < e.length && (i = n.indexOf(e[s]), i === -1 || i < o); s++) ;
    return i === -1 || i === o && r === n[o] && (i++, i >= n.length) ? -1 : (e = n.slice(), i);
  };
}
function Ue(t, e) {
  const n = e[0];
  if (Qe(n) || Lt(n) || Wt(n)) {
    const r = qt(t, e);
    return { advance: r.advance, node: r.node };
  }
  if (Rt(n)) {
    const r = $t(t, e);
    return { advance: r.advance, node: r.node };
  }
  if (Re(n)) {
    const r = et(t, e);
    return { advance: r.advance, node: r.node };
  }
  if (Ke(n)) {
    const r = zt(t, e);
    return { advance: r.advance, node: r.node };
  }
  return { advance: 1, node: new d(n) };
}
(function(t) {
  t.Function = "function", t.SimpleBlock = "simple-block", t.Whitespace = "whitespace", t.Comment = "comment", t.Token = "token";
})(U || (U = {}));
class _e {
  constructor() {
    C(this, "value", []);
  }
  indexOf(e) {
    return this.value.indexOf(e);
  }
  at(e) {
    if (typeof e == "number") return e < 0 && (e = this.value.length + e), this.value[e];
  }
  forEach(e, n) {
    if (this.value.length === 0) return;
    const r = Xe(this.value);
    let o = 0;
    for (; o < this.value.length; ) {
      const i = this.value[o];
      let s;
      if (n && (s = { ...n }), e({ node: i, parent: this, state: s }, o) === !1) return !1;
      if (o = r(this.value, i, o), o === -1) break;
    }
  }
  walk(e, n) {
    this.value.length !== 0 && this.forEach((r, o) => e(r, o) !== !1 && (!("walk" in r.node) || !this.value.includes(r.node) || r.node.walk(e, r.state) !== !1) && void 0, n);
  }
}
class F extends _e {
  constructor(n, r, o) {
    super();
    C(this, "type", U.Function);
    C(this, "name");
    C(this, "endToken");
    this.name = n, this.endToken = r, this.value = o;
  }
  getName() {
    return this.name[4].value;
  }
  normalize() {
    Y(this.endToken) && (this.endToken = [a.CloseParen, ")", -1, -1, void 0]);
  }
  tokens() {
    return Y(this.endToken) ? [this.name, ...this.value.flatMap((n) => n.tokens())] : [this.name, ...this.value.flatMap((n) => n.tokens()), this.endToken];
  }
  toString() {
    const n = this.value.map((r) => Ye(r) ? j(r) : r.toString()).join("");
    return j(this.name) + n + j(this.endToken);
  }
  toJSON() {
    return { type: this.type, name: this.getName(), tokens: this.tokens(), value: this.value.map((n) => n.toJSON()) };
  }
  isFunctionNode() {
    return F.isFunctionNode(this);
  }
  static isFunctionNode(n) {
    return !!n && n instanceof F && n.type === U.Function;
  }
}
function $t(t, e) {
  const n = [];
  let r = 1;
  for (; ; ) {
    const o = e[r];
    if (!o || Y(o)) return t.onParseError(new Se("Unexpected EOF while consuming a function.", e[0][2], e[e.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), { advance: e.length, node: new F(e[0], o, n) };
    if (Ut(o)) return { advance: r + 1, node: new F(e[0], o, n) };
    if (Ze(o)) {
      const s = tt(t, e.slice(r));
      r += s.advance, n.push(...s.nodes);
      continue;
    }
    const i = Ue(t, e.slice(r));
    r += i.advance, n.push(i.node);
  }
}
class ae extends _e {
  constructor(n, r, o) {
    super();
    C(this, "type", U.SimpleBlock);
    C(this, "startToken");
    C(this, "endToken");
    this.startToken = n, this.endToken = r, this.value = o;
  }
  normalize() {
    if (Y(this.endToken)) {
      const n = yt(this.startToken);
      n && (this.endToken = n);
    }
  }
  tokens() {
    return Y(this.endToken) ? [this.startToken, ...this.value.flatMap((n) => n.tokens())] : [this.startToken, ...this.value.flatMap((n) => n.tokens()), this.endToken];
  }
  toString() {
    const n = this.value.map((r) => Ye(r) ? j(r) : r.toString()).join("");
    return j(this.startToken) + n + j(this.endToken);
  }
  toJSON() {
    return { type: this.type, startToken: this.startToken, tokens: this.tokens(), value: this.value.map((n) => n.toJSON()) };
  }
  isSimpleBlockNode() {
    return ae.isSimpleBlockNode(this);
  }
  static isSimpleBlockNode(n) {
    return !!n && n instanceof ae && n.type === U.SimpleBlock;
  }
}
function qt(t, e) {
  const n = Ct(e[0][0]);
  if (!n) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
  const r = [];
  let o = 1;
  for (; ; ) {
    const i = e[o];
    if (!i || Y(i)) return t.onParseError(new Se("Unexpected EOF while consuming a simple block.", e[0][2], e[e.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), { advance: e.length, node: new ae(e[0], i, r) };
    if (i[0] === n) return { advance: o + 1, node: new ae(e[0], i, r) };
    if (Ze(i)) {
      const u = tt(t, e.slice(o));
      o += u.advance, r.push(...u.nodes);
      continue;
    }
    const s = Ue(t, e.slice(o));
    o += s.advance, r.push(s.node);
  }
}
class T {
  constructor(e) {
    C(this, "type", U.Whitespace);
    C(this, "value");
    this.value = e;
  }
  tokens() {
    return this.value;
  }
  toString() {
    return j(...this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isWhitespaceNode() {
    return T.isWhitespaceNode(this);
  }
  static isWhitespaceNode(e) {
    return !!e && e instanceof T && e.type === U.Whitespace;
  }
}
function et(t, e) {
  let n = 0;
  for (; ; ) {
    const r = e[n];
    if (!Re(r)) return { advance: n, node: new T(e.slice(0, n)) };
    n++;
  }
}
class se {
  constructor(e) {
    C(this, "type", U.Comment);
    C(this, "value");
    this.value = e;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return j(this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isCommentNode() {
    return se.isCommentNode(this);
  }
  static isCommentNode(e) {
    return !!e && e instanceof se && e.type === U.Comment;
  }
}
function zt(t, e) {
  return { advance: 1, node: new se(e[0]) };
}
function tt(t, e) {
  const n = [];
  let r = 0;
  for (; ; ) if (Re(e[r])) {
    const o = et(0, e.slice(r));
    r += o.advance, n.push(o.node);
  } else {
    if (!Ke(e[r])) return { advance: r, nodes: n };
    n.push(new se(e[r])), r++;
  }
}
class d {
  constructor(e) {
    C(this, "type", U.Token);
    C(this, "value");
    this.value = e;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return this.value[1];
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isTokenNode() {
    return d.isTokenNode(this);
  }
  static isTokenNode(e) {
    return !!e && e instanceof d && e.type === U.Token;
  }
}
function Vt(t, e) {
  const n = { onParseError: (e == null ? void 0 : e.onParseError) ?? (() => {
  }) }, r = [...t];
  if (t.length === 0) return [];
  Y(r[r.length - 1]) && r.push([a.EOF, "", r[r.length - 1][2], r[r.length - 1][3], void 0]);
  const o = [];
  let i = [], s = 0;
  for (; ; ) {
    if (!r[s] || Y(r[s])) return i.length && o.push(i), o;
    if (ie(r[s])) {
      o.push(i), i = [], s++;
      continue;
    }
    const u = Ue(n, t.slice(s));
    i.push(u.node), s += u.advance;
  }
}
function Ht(t, e, n) {
  if (t.length === 0) return;
  const r = Xe(t);
  let o = 0;
  for (; o < t.length; ) {
    const i = t[o];
    if (e({ node: i, parent: { value: t }, state: void 0 }, o) === !1) return !1;
    if (o = r(t, i, o), o === -1) break;
  }
}
function jt(t, e, n) {
  t.length !== 0 && Ht(t, (r, o) => e(r, o) !== !1 && (!("walk" in r.node) || !t.includes(r.node) || r.node.walk(e, r.state) !== !1) && void 0);
}
function Gt(t, e) {
  for (let n = 0; n < t.length; n++)
    jt(t[n], (r, o) => {
      if (typeof o != "number") return;
      const i = e(r.node);
      i && (Array.isArray(i) ? r.parent.value.splice(o, 1, ...i) : r.parent.value.splice(o, 1, i));
    });
  return t;
}
function Jt(t) {
  return ae.isSimpleBlockNode(t);
}
function le(t) {
  return F.isFunctionNode(t);
}
function nt(t) {
  return T.isWhitespaceNode(t);
}
function rt(t) {
  return se.isCommentNode(t);
}
function X(t) {
  return nt(t) || rt(t);
}
function m(t) {
  return d.isTokenNode(t);
}
const Yt = /[A-Z]/g;
function O(t) {
  return t.replace(Yt, (e) => String.fromCharCode(e.charCodeAt(0) + 32));
}
const Zt = /* @__PURE__ */ new Map([["cm", (t) => t], ["mm", (t) => 10 * t], ["q", (t) => 40 * t], ["in", (t) => t / 2.54], ["pc", (t) => t / 2.54 * 6], ["pt", (t) => t / 2.54 * 72], ["px", (t) => t / 2.54 * 96]]), Be = /* @__PURE__ */ new Map([["deg", (t) => t], ["grad", (t) => t / 0.9], ["rad", (t) => t / 180 * Math.PI], ["turn", (t) => t / 360]]), ge = /* @__PURE__ */ new Map([["deg", (t) => 0.9 * t], ["grad", (t) => t], ["rad", (t) => 0.9 * t / 180 * Math.PI], ["turn", (t) => 0.9 * t / 360]]), Kt = /* @__PURE__ */ new Map([["hz", (t) => t], ["khz", (t) => t / 1e3]]), Qt = /* @__PURE__ */ new Map([["cm", (t) => 2.54 * t], ["mm", (t) => 25.4 * t], ["q", (t) => 25.4 * t * 4], ["in", (t) => t], ["pc", (t) => 6 * t], ["pt", (t) => 72 * t], ["px", (t) => 96 * t]]), Xt = /* @__PURE__ */ new Map([["hz", (t) => 1e3 * t], ["khz", (t) => t]]), _t = /* @__PURE__ */ new Map([["cm", (t) => t / 10], ["mm", (t) => t], ["q", (t) => 4 * t], ["in", (t) => t / 25.4], ["pc", (t) => t / 25.4 * 6], ["pt", (t) => t / 25.4 * 72], ["px", (t) => t / 25.4 * 96]]), en = /* @__PURE__ */ new Map([["ms", (t) => t], ["s", (t) => t / 1e3]]), tn = /* @__PURE__ */ new Map([["cm", (t) => t / 6 * 2.54], ["mm", (t) => t / 6 * 25.4], ["q", (t) => t / 6 * 25.4 * 4], ["in", (t) => t / 6], ["pc", (t) => t], ["pt", (t) => t / 6 * 72], ["px", (t) => t / 6 * 96]]), nn = /* @__PURE__ */ new Map([["cm", (t) => t / 72 * 2.54], ["mm", (t) => t / 72 * 25.4], ["q", (t) => t / 72 * 25.4 * 4], ["in", (t) => t / 72], ["pc", (t) => t / 72 * 6], ["pt", (t) => t], ["px", (t) => t / 72 * 96]]), rn = /* @__PURE__ */ new Map([["cm", (t) => t / 96 * 2.54], ["mm", (t) => t / 96 * 25.4], ["q", (t) => t / 96 * 25.4 * 4], ["in", (t) => t / 96], ["pc", (t) => t / 96 * 6], ["pt", (t) => t / 96 * 72], ["px", (t) => t]]), on = /* @__PURE__ */ new Map([["cm", (t) => t / 4 / 10], ["mm", (t) => t / 4], ["q", (t) => t], ["in", (t) => t / 4 / 25.4], ["pc", (t) => t / 4 / 25.4 * 6], ["pt", (t) => t / 4 / 25.4 * 72], ["px", (t) => t / 4 / 25.4 * 96]]), ot = /* @__PURE__ */ new Map([["deg", (t) => 180 * t / Math.PI], ["grad", (t) => 180 * t / Math.PI / 0.9], ["rad", (t) => t], ["turn", (t) => 180 * t / Math.PI / 360]]), an = /* @__PURE__ */ new Map([["ms", (t) => 1e3 * t], ["s", (t) => t]]), me = /* @__PURE__ */ new Map([["deg", (t) => 360 * t], ["grad", (t) => 360 * t / 0.9], ["rad", (t) => 360 * t / 180 * Math.PI], ["turn", (t) => t]]), sn = /* @__PURE__ */ new Map([["cm", Zt], ["mm", _t], ["q", on], ["in", Qt], ["pc", tn], ["pt", nn], ["px", rn], ["ms", en], ["s", an], ["deg", Be], ["grad", ge], ["rad", ot], ["turn", me], ["hz", Kt], ["khz", Xt]]);
function M(t, e) {
  if (!y(t) || !y(e)) return e;
  const n = O(t[4].unit), r = O(e[4].unit);
  if (n === r) return e;
  const o = sn.get(r);
  if (!o) return e;
  const i = o.get(n);
  if (!i) return e;
  const s = i(e[4].value), u = [a.Dimension, "", e[2], e[3], { ...e[4], signCharacter: s < 0 ? "-" : void 0, type: Number.isInteger(s) ? l.Integer : l.Number, value: s }];
  return Tt(u, t[4].unit), u;
}
function un(t) {
  if (t.length !== 2) return -1;
  const e = t[0].value;
  let n = t[1].value;
  if (g(e) && g(n)) {
    const r = e[4].value + n[4].value;
    return new d([a.Number, r.toString(), e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number }]);
  }
  if (P(e) && P(n)) {
    const r = e[4].value + n[4].value;
    return new d([a.Percentage, r.toString() + "%", e[2], n[3], { value: r }]);
  }
  if (y(e) && y(n) && (n = M(e, n), O(e[4].unit) === O(n[4].unit))) {
    const r = e[4].value + n[4].value;
    return new d([a.Dimension, r.toString() + e[4].unit, e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number, unit: e[4].unit }]);
  }
  return -1;
}
function cn(t) {
  if (t.length !== 2) return -1;
  const e = t[0].value, n = t[1].value;
  if (g(e) && g(n)) {
    const r = e[4].value / n[4].value;
    return new d([a.Number, r.toString(), e[2], n[3], { value: r, type: Number.isInteger(r) ? l.Integer : l.Number }]);
  }
  if (P(e) && g(n)) {
    const r = e[4].value / n[4].value;
    return new d([a.Percentage, r.toString() + "%", e[2], n[3], { value: r }]);
  }
  if (y(e) && g(n)) {
    const r = e[4].value / n[4].value;
    return new d([a.Dimension, r.toString() + e[4].unit, e[2], n[3], { value: r, type: Number.isInteger(r) ? l.Integer : l.Number, unit: e[4].unit }]);
  }
  return -1;
}
function Z(t) {
  return !!t && typeof t == "object" && "inputs" in t && Array.isArray(t.inputs) && "operation" in t;
}
function N(t) {
  if (t === -1) return -1;
  const e = [];
  for (let n = 0; n < t.inputs.length; n++) {
    const r = t.inputs[n];
    if (m(r)) {
      e.push(r);
      continue;
    }
    const o = N(r);
    if (o === -1) return -1;
    e.push(o);
  }
  return t.operation(e);
}
function ln(t) {
  if (t.length !== 2) return -1;
  const e = t[0].value, n = t[1].value;
  if (g(e) && g(n)) {
    const r = e[4].value * n[4].value;
    return new d([a.Number, r.toString(), e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number }]);
  }
  if (P(e) && g(n)) {
    const r = e[4].value * n[4].value;
    return new d([a.Percentage, r.toString() + "%", e[2], n[3], { value: r }]);
  }
  if (g(e) && P(n)) {
    const r = e[4].value * n[4].value;
    return new d([a.Percentage, r.toString() + "%", e[2], n[3], { value: r }]);
  }
  if (y(e) && g(n)) {
    const r = e[4].value * n[4].value;
    return new d([a.Dimension, r.toString() + e[4].unit, e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number, unit: e[4].unit }]);
  }
  if (g(e) && y(n)) {
    const r = e[4].value * n[4].value;
    return new d([a.Dimension, r.toString() + n[4].unit, e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number, unit: n[4].unit }]);
  }
  return -1;
}
function ue(t, e) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (!m(r)) continue;
    const o = r.value;
    if (!ve(o)) continue;
    const i = O(o[4].value);
    switch (i) {
      case "e":
        t.splice(n, 1, new d([a.Number, Math.E.toString(), o[2], o[3], { value: Math.E, type: l.Number }]));
        break;
      case "pi":
        t.splice(n, 1, new d([a.Number, Math.PI.toString(), o[2], o[3], { value: Math.PI, type: l.Number }]));
        break;
      case "infinity":
        t.splice(n, 1, new d([a.Number, "infinity", o[2], o[3], { value: 1 / 0, type: l.Number }]));
        break;
      case "-infinity":
        t.splice(n, 1, new d([a.Number, "-infinity", o[2], o[3], { value: -1 / 0, type: l.Number }]));
        break;
      case "nan":
        t.splice(n, 1, new d([a.Number, "NaN", o[2], o[3], { value: Number.NaN, type: l.Number }]));
        break;
      default:
        if (e.has(i)) {
          const s = e.get(i);
          t.splice(n, 1, new d(s));
        }
    }
  }
  return t;
}
function Fe(t) {
  if (t.length !== 1) return -1;
  const e = t[0].value;
  return b(e) ? t[0] : -1;
}
function w(t, e, n) {
  return y(e) ? he(t, e[4].unit, n) : P(e) ? dn(t, n) : g(e) ? z(t, n) : -1;
}
function he(t, e, n) {
  const r = t.tokens();
  return { inputs: [new d([a.Dimension, n.toString() + e, r[0][2], r[r.length - 1][3], { value: n, type: Number.isInteger(n) ? l.Integer : l.Number, unit: e }])], operation: Fe };
}
function dn(t, e) {
  const n = t.tokens();
  return { inputs: [new d([a.Percentage, e.toString() + "%", n[0][2], n[n.length - 1][3], { value: e }])], operation: Fe };
}
function z(t, e) {
  const n = t.tokens();
  return { inputs: [new d([a.Number, e.toString(), n[0][2], n[n.length - 1][3], { value: e, type: Number.isInteger(e) ? l.Integer : l.Number }])], operation: Fe };
}
function pn(t, e) {
  const n = e.value;
  return g(n) ? he(t, "rad", Math.acos(n[4].value)) : -1;
}
function fn(t, e) {
  const n = e.value;
  return g(n) ? he(t, "rad", Math.asin(n[4].value)) : -1;
}
function vn(t, e) {
  const n = e.value;
  return g(n) ? he(t, "rad", Math.atan(n[4].value)) : -1;
}
function Ne(t) {
  return y(t) || g(t);
}
function We(t) {
  if (t.length === 0) return !0;
  const e = t[0];
  if (!b(e)) return !1;
  if (t.length === 1) return !0;
  if (y(e)) {
    const n = O(e[4].unit);
    for (let r = 1; r < t.length; r++) {
      const o = t[r];
      if (e[0] !== o[0] || n !== O(o[4].unit)) return !1;
    }
    return !0;
  }
  for (let n = 1; n < t.length; n++) {
    const r = t[n];
    if (e[0] !== r[0]) return !1;
  }
  return !0;
}
function G(t, e) {
  return !!b(t) && (y(t) ? t[0] === e[0] && O(t[4].unit) === O(e[4].unit) : t[0] === e[0]);
}
function gn(t, e, n) {
  const r = e.value;
  if (!Ne(r)) return -1;
  const o = M(r, n.value);
  return G(r, o) ? he(t, "rad", Math.atan2(r[4].value, o[4].value)) : -1;
}
function mn(t, e, n) {
  const r = e.value;
  return !b(r) || !n.rawPercentages && P(r) ? -1 : w(t, r, Math.abs(r[4].value));
}
function hn(t, e, n, r, o) {
  if (!m(e) || !m(n) || !m(r)) return -1;
  const i = e.value;
  if (!b(i) || !o.rawPercentages && P(i)) return -1;
  const s = M(i, n.value);
  if (!G(i, s)) return -1;
  const u = M(i, r.value);
  return G(i, u) ? w(t, i, Math.max(i[4].value, Math.min(s[4].value, u[4].value))) : -1;
}
function Cn(t, e) {
  const n = e.value;
  if (!Ne(n)) return -1;
  let r = n[4].value;
  if (y(n)) switch (n[4].unit.toLowerCase()) {
    case "rad":
      break;
    case "deg":
      r = Be.get("rad")(n[4].value);
      break;
    case "grad":
      r = ge.get("rad")(n[4].value);
      break;
    case "turn":
      r = me.get("rad")(n[4].value);
      break;
    default:
      return -1;
  }
  return r = Math.cos(r), z(t, r);
}
function yn(t, e) {
  const n = e.value;
  return g(n) ? z(t, Math.exp(n[4].value)) : -1;
}
function En(t, e, n) {
  if (!e.every(m)) return -1;
  const r = e[0].value;
  if (!b(r) || !n.rawPercentages && P(r)) return -1;
  const o = e.map((u) => M(r, u.value));
  if (!We(o)) return -1;
  const i = o.map((u) => u[4].value), s = Math.hypot(...i);
  return w(t, r, s);
}
function ze(t, e, n) {
  if (!e.every(m)) return -1;
  const r = e[0].value;
  if (!b(r) || !n.rawPercentages && P(r)) return -1;
  const o = e.map((u) => M(r, u.value));
  if (!We(o)) return -1;
  const i = o.map((u) => u[4].value), s = Math.max(...i);
  return w(t, r, s);
}
function Ve(t, e, n) {
  if (!e.every(m)) return -1;
  const r = e[0].value;
  if (!b(r) || !n.rawPercentages && P(r)) return -1;
  const o = e.map((u) => M(r, u.value));
  if (!We(o)) return -1;
  const i = o.map((u) => u[4].value), s = Math.min(...i);
  return w(t, r, s);
}
function Pn(t, e, n) {
  const r = e.value;
  if (!b(r)) return -1;
  const o = M(r, n.value);
  if (!G(r, o)) return -1;
  let i;
  return i = o[4].value === 0 ? Number.NaN : Number.isFinite(r[4].value) && (Number.isFinite(o[4].value) || (o[4].value !== Number.POSITIVE_INFINITY || r[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r[4].value, -0)) && (o[4].value !== Number.NEGATIVE_INFINITY || r[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r[4].value, 0))) ? Number.isFinite(o[4].value) ? (r[4].value % o[4].value + o[4].value) % o[4].value : r[4].value : Number.NaN, w(t, r, i);
}
function kn(t, e, n) {
  const r = e.value, o = n.value;
  return !g(r) || !G(r, o) ? -1 : z(t, Math.pow(r[4].value, o[4].value));
}
function bn(t, e, n) {
  const r = e.value;
  if (!b(r)) return -1;
  const o = M(r, n.value);
  if (!G(r, o)) return -1;
  let i;
  return i = o[4].value === 0 ? Number.NaN : Number.isFinite(r[4].value) ? Number.isFinite(o[4].value) ? r[4].value % o[4].value : r[4].value : Number.NaN, w(t, r, i);
}
function Sn(t, e, n, r, o) {
  const i = n.value;
  if (!b(i) || !o.rawPercentages && P(i)) return -1;
  const s = M(i, r.value);
  if (!G(i, s)) return -1;
  let u;
  if (s[4].value === 0) u = Number.NaN;
  else if (Number.isFinite(i[4].value) || Number.isFinite(s[4].value)) if (!Number.isFinite(i[4].value) && Number.isFinite(s[4].value)) u = i[4].value;
  else if (Number.isFinite(i[4].value) && !Number.isFinite(s[4].value)) switch (e) {
    case "down":
      u = i[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * i[4].value) ? -0 : 0;
      break;
    case "up":
      u = i[4].value > 0 ? 1 / 0 : Object.is(0, 0 * i[4].value) ? 0 : -0;
      break;
    default:
      u = Object.is(0, 0 * i[4].value) ? 0 : -0;
  }
  else if (Number.isFinite(s[4].value)) switch (e) {
    case "down":
      u = Math.floor(i[4].value / s[4].value) * s[4].value;
      break;
    case "up":
      u = Math.ceil(i[4].value / s[4].value) * s[4].value;
      break;
    case "to-zero":
      u = Math.trunc(i[4].value / s[4].value) * s[4].value;
      break;
    default: {
      let c = Math.floor(i[4].value / s[4].value) * s[4].value, p = Math.ceil(i[4].value / s[4].value) * s[4].value;
      if (c > p) {
        const S = c;
        c = p, p = S;
      }
      const f = Math.abs(i[4].value - c), v = Math.abs(i[4].value - p);
      u = f === v ? p : f < v ? c : p;
      break;
    }
  }
  else u = i[4].value;
  else u = Number.NaN;
  return w(t, i, u);
}
function An(t, e, n) {
  const r = e.value;
  return !b(r) || !n.rawPercentages && P(r) ? -1 : z(t, Math.sign(r[4].value));
}
function Dn(t, e) {
  const n = e.value;
  if (!Ne(n)) return -1;
  let r = n[4].value;
  if (y(n)) switch (O(n[4].unit)) {
    case "rad":
      break;
    case "deg":
      r = Be.get("rad")(n[4].value);
      break;
    case "grad":
      r = ge.get("rad")(n[4].value);
      break;
    case "turn":
      r = me.get("rad")(n[4].value);
      break;
    default:
      return -1;
  }
  return r = Math.sin(r), z(t, r);
}
function Bn(t, e) {
  const n = e.value;
  return g(n) ? z(t, Math.sqrt(n[4].value)) : -1;
}
function Fn(t, e) {
  const n = e.value;
  if (!Ne(n)) return -1;
  const r = n[4].value;
  let o = 0, i = n[4].value;
  if (y(n)) switch (O(n[4].unit)) {
    case "rad":
      o = ot.get("deg")(r);
      break;
    case "deg":
      o = r, i = Be.get("rad")(r);
      break;
    case "grad":
      o = ge.get("deg")(r), i = ge.get("rad")(r);
      break;
    case "turn":
      o = me.get("deg")(r), i = me.get("rad")(r);
      break;
    default:
      return -1;
  }
  const s = o / 90;
  return i = o % 90 == 0 && s % 2 != 0 ? s > 0 ? 1 / 0 : -1 / 0 : Math.tan(i), z(t, i);
}
function Nn(t) {
  if (t.length !== 2) return -1;
  const e = t[0].value;
  let n = t[1].value;
  if (g(e) && g(n)) {
    const r = e[4].value - n[4].value;
    return new d([a.Number, r.toString(), e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number }]);
  }
  if (P(e) && P(n)) {
    const r = e[4].value - n[4].value;
    return new d([a.Percentage, r.toString() + "%", e[2], n[3], { value: r }]);
  }
  if (y(e) && y(n) && (n = M(e, n), O(e[4].unit) === O(n[4].unit))) {
    const r = e[4].value - n[4].value;
    return new d([a.Dimension, r.toString() + e[4].unit, e[2], n[3], { value: r, type: e[4].type === l.Integer && n[4].type === l.Integer ? l.Integer : l.Number, unit: e[4].unit }]);
  }
  return -1;
}
function wn(t, e) {
  if (e.length === 1) {
    const n = e[0];
    if (!n || !m(n)) return -1;
    const r = n.value;
    return g(r) ? z(t, Math.log(r[4].value)) : -1;
  }
  if (e.length === 2) {
    const n = e[0];
    if (!n || !m(n)) return -1;
    const r = n.value;
    if (!g(r)) return -1;
    const o = e[1];
    if (!o || !m(o)) return -1;
    const i = o.value;
    return g(i) ? z(t, Math.log(r[4].value) / Math.log(i[4].value)) : -1;
  }
  return -1;
}
const In = /^none$/i;
function Oe(t) {
  if (Array.isArray(t)) {
    const n = t.filter((r) => !(nt(r) && rt(r)));
    return n.length === 1 && Oe(n[0]);
  }
  if (!m(t)) return !1;
  const e = t.value;
  return !!ve(e) && In.test(e[4].value);
}
const xn = String.fromCodePoint(0);
function Tn(t, e, n, r, o, i) {
  var E;
  if (e.fixed === -1 && !i.randomCaching) return -1;
  i.randomCaching || (i.randomCaching = { propertyName: "", propertyN: 0, elementID: "", documentID: "" }), i.randomCaching && !i.randomCaching.propertyN && (i.randomCaching.propertyN = 0);
  const s = n.value;
  if (!b(s)) return -1;
  const u = M(s, r.value);
  if (!G(s, u)) return -1;
  let c = null;
  if (o && (c = M(s, o.value), !G(s, c))) return -1;
  if (!Number.isFinite(s[4].value) || !Number.isFinite(u[4].value) || !Number.isFinite(u[4].value - s[4].value)) return w(t, s, Number.NaN);
  if (c && !Number.isFinite(c[4].value)) return w(t, s, s[4].value);
  const p = e.fixed === -1 ? On(Mn([e.dashedIdent ? e.dashedIdent : `${(E = i.randomCaching) == null ? void 0 : E.propertyName} ${i.randomCaching.propertyN++}`, e.elementShared ? "" : i.randomCaching.elementID, i.randomCaching.documentID].join(xn))) : () => e.fixed;
  let f = s[4].value, v = u[4].value;
  if (f > v && ([f, v] = [v, f]), c && (c[4].value <= 0 || Math.abs(f - v) / c[4].value > 1e10) && (c = null), c) {
    const I = Math.max(c[4].value / 1e3, 1e-9), h = [f];
    let L = 0;
    for (; ; ) {
      L += c[4].value;
      const de = f + L;
      if (!(de + I < v)) {
        h.push(v);
        break;
      }
      if (h.push(de), de + c[4].value - I > v) break;
    }
    const V = p();
    return w(t, s, Number(h[Math.floor(h.length * V)].toFixed(5)));
  }
  const S = p();
  return w(t, s, Number((S * (v - f) + f).toFixed(5)));
}
function On(t = 0.34944106645296036, e = 0.19228640875738723, n = 0.8784393832007205, r = 0.04850964319275053) {
  return () => {
    const o = ((t |= 0) + (e |= 0) | 0) + (r |= 0) | 0;
    return r = r + 1 | 0, t = e ^ e >>> 9, e = (n |= 0) + (n << 3) | 0, n = (n = n << 21 | n >>> 11) + o | 0, (o >>> 0) / 4294967296;
  };
}
function Mn(t) {
  let e = 0, n = 0, r = 0;
  e = ~e;
  for (let o = 0, i = t.length; o < i; o++) r = 255 & (e ^ t.charCodeAt(o)), n = +("0x" + "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".substring(9 * r, 9 * r + 8)), e = e >>> 8 ^ n;
  return ~e >>> 0;
}
const Le = /* @__PURE__ */ new Map([["abs", function(e, n, r) {
  return $(e, n, r, mn);
}], ["acos", function(e, n, r) {
  return $(e, n, r, pn);
}], ["asin", function(e, n, r) {
  return $(e, n, r, fn);
}], ["atan", function(e, n, r) {
  return $(e, n, r, vn);
}], ["atan2", function(e, n, r) {
  return Ce(e, n, r, gn);
}], ["calc", B], ["clamp", function(e, n, r) {
  const o = ue([...e.value.filter((h) => !X(h))], n), i = [], s = [], u = [];
  {
    let h = i;
    for (let L = 0; L < o.length; L++) {
      const V = o[L];
      if (m(V) && ie(V.value)) {
        if (h === u) return -1;
        if (h === s) {
          h = u;
          continue;
        }
        if (h === i) {
          h = s;
          continue;
        }
        return -1;
      }
      h.push(V);
    }
  }
  const c = Oe(i), p = Oe(u);
  if (c && p) return B(x(s), n, r);
  const f = N(B(x(s), n, r));
  if (f === -1) return -1;
  if (c) {
    const h = N(B(x(u), n, r));
    return h === -1 ? -1 : Ve((v = f, S = h, new F([a.Function, "min(", -1, -1, { value: "min" }], [a.CloseParen, ")", -1, -1, void 0], [v, new d([a.Comma, ",", -1, -1, void 0]), S])), [f, h], r);
  }
  if (p) {
    const h = N(B(x(i), n, r));
    return h === -1 ? -1 : ze($n(h, f), [h, f], r);
  }
  var v, S;
  const E = N(B(x(i), n, r));
  if (E === -1) return -1;
  const I = N(B(x(u), n, r));
  return I === -1 ? -1 : hn(e, E, f, I, r);
}], ["cos", function(e, n, r) {
  return $(e, n, r, Cn);
}], ["exp", function(e, n, r) {
  return $(e, n, r, yn);
}], ["hypot", function(e, n, r) {
  return ye(e, e.value, n, r, En);
}], ["log", function(e, n, r) {
  return ye(e, e.value, n, r, wn);
}], ["max", function(e, n, r) {
  return ye(e, e.value, n, r, ze);
}], ["min", function(e, n, r) {
  return ye(e, e.value, n, r, Ve);
}], ["mod", function(e, n, r) {
  return Ce(e, n, r, Pn);
}], ["pow", function(e, n, r) {
  return Ce(e, n, r, kn);
}], ["random", function(e, n, r) {
  const o = Ln(e.value.filter((v) => !X(v)), n, r);
  if (o === -1) return -1;
  const [i, s] = o, u = it(s, n, r);
  if (u === -1) return -1;
  const [c, p, f] = u;
  return !c || !p ? -1 : Tn(e, i, c, p, f, r);
}], ["rem", function(e, n, r) {
  return Ce(e, n, r, bn);
}], ["round", function(e, n, r) {
  const o = ue([...e.value.filter((v) => !X(v))], n);
  let i = "", s = !1;
  const u = [], c = [];
  {
    let v = u;
    for (let S = 0; S < o.length; S++) {
      const E = o[S];
      if (!i && u.length === 0 && c.length === 0 && m(E) && ve(E.value)) {
        const I = E.value[4].value.toLowerCase();
        if (Wn.has(I)) {
          i = I;
          continue;
        }
      }
      if (m(E) && ie(E.value)) {
        if (v === c) return -1;
        if (v === u && i && u.length === 0) continue;
        if (v === u) {
          s = !0, v = c;
          continue;
        }
        return -1;
      }
      v.push(E);
    }
  }
  const p = N(B(x(u), n, r));
  if (p === -1) return -1;
  s || c.length !== 0 || c.push(new d([a.Number, "1", -1, -1, { value: 1, type: l.Integer }]));
  const f = N(B(x(c), n, r));
  return f === -1 ? -1 : (i || (i = "nearest"), Sn(e, i, p, f, r));
}], ["sign", function(e, n, r) {
  return $(e, n, r, An);
}], ["sin", function(e, n, r) {
  return $(e, n, r, Dn);
}], ["sqrt", function(e, n, r) {
  return $(e, n, r, Bn);
}], ["tan", function(e, n, r) {
  return $(e, n, r, Fn);
}]]);
function B(t, e, n) {
  const r = ue([...t.value.filter((i) => !X(i))], e);
  if (r.length === 1 && m(r[0])) return { inputs: [r[0]], operation: Fe };
  let o = 0;
  for (; o < r.length; ) {
    const i = r[o];
    if (Jt(i) && Qe(i.startToken)) {
      const s = B(i, e, n);
      if (s === -1) return -1;
      r.splice(o, 1, s);
    } else if (le(i)) {
      const s = Le.get(i.getName().toLowerCase());
      if (!s) return -1;
      const u = s(i, e, n);
      if (u === -1) return -1;
      r.splice(o, 1, u);
    } else o++;
  }
  if (o = 0, r.length === 1 && Z(r[0])) return r[0];
  for (; o < r.length; ) {
    const i = r[o];
    if (!i || !m(i) && !Z(i)) {
      o++;
      continue;
    }
    const s = r[o + 1];
    if (!s || !m(s)) {
      o++;
      continue;
    }
    const u = s.value;
    if (!qe(u) || u[4].value !== "*" && u[4].value !== "/") {
      o++;
      continue;
    }
    const c = r[o + 2];
    if (!c || !m(c) && !Z(c)) return -1;
    u[4].value !== "*" ? u[4].value !== "/" ? o++ : r.splice(o, 3, { inputs: [i, c], operation: cn }) : r.splice(o, 3, { inputs: [i, c], operation: ln });
  }
  if (o = 0, r.length === 1 && Z(r[0])) return r[0];
  for (; o < r.length; ) {
    const i = r[o];
    if (!i || !m(i) && !Z(i)) {
      o++;
      continue;
    }
    const s = r[o + 1];
    if (!s || !m(s)) {
      o++;
      continue;
    }
    const u = s.value;
    if (!qe(u) || u[4].value !== "+" && u[4].value !== "-") {
      o++;
      continue;
    }
    const c = r[o + 2];
    if (!c || !m(c) && !Z(c)) return -1;
    u[4].value !== "+" ? u[4].value !== "-" ? o++ : r.splice(o, 3, { inputs: [i, c], operation: Nn }) : r.splice(o, 3, { inputs: [i, c], operation: un });
  }
  return r.length === 1 && Z(r[0]) ? r[0] : -1;
}
function $(t, e, n, r) {
  const o = Rn(t.value, e, n);
  return o === -1 ? -1 : r(t, o, n);
}
function Rn(t, e, n) {
  const r = N(B(x(ue([...t.filter((o) => !X(o))], e)), e, n));
  return r === -1 ? -1 : r;
}
function Ce(t, e, n, r) {
  const o = Un(t.value, e, n);
  if (o === -1) return -1;
  const [i, s] = o;
  return r(t, i, s, n);
}
function Un(t, e, n) {
  const r = ue([...t.filter((c) => !X(c))], e), o = [], i = [];
  {
    let c = o;
    for (let p = 0; p < r.length; p++) {
      const f = r[p];
      if (m(f) && ie(f.value)) {
        if (c === i) return -1;
        if (c === o) {
          c = i;
          continue;
        }
        return -1;
      }
      c.push(f);
    }
  }
  const s = N(B(x(o), e, n));
  if (s === -1) return -1;
  const u = N(B(x(i), e, n));
  return u === -1 ? -1 : [s, u];
}
function ye(t, e, n, r, o) {
  const i = it(t.value, n, r);
  return i === -1 ? -1 : o(t, i, r);
}
function it(t, e, n) {
  const r = ue([...t.filter((i) => !X(i))], e), o = [];
  {
    const i = [];
    let s = [];
    for (let u = 0; u < r.length; u++) {
      const c = r[u];
      m(c) && ie(c.value) ? (i.push(s), s = []) : s.push(c);
    }
    i.push(s);
    for (let u = 0; u < i.length; u++) {
      if (i[u].length === 0) return -1;
      const c = N(B(x(i[u]), e, n));
      if (c === -1) return -1;
      o.push(c);
    }
  }
  return o;
}
const Wn = /* @__PURE__ */ new Set(["nearest", "up", "down", "to-zero"]);
function Ln(t, e, n) {
  const r = { isAuto: !1, dashedIdent: "", fixed: -1, elementShared: !1 }, o = t[0];
  if (!m(o) || !ve(o.value)) return [r, t];
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    if (!m(s)) return -1;
    if (ie(s.value)) return [r, t.slice(i + 1)];
    if (!ve(s.value)) return -1;
    const u = s.value[4].value.toLowerCase();
    if (u !== "element-shared") if (u !== "fixed") if (u !== "auto") {
      if (u.startsWith("--")) {
        if (r.fixed !== -1 || r.isAuto) return -1;
        r.dashedIdent = u;
      }
    } else {
      if (r.fixed !== -1 || r.dashedIdent) return -1;
      r.isAuto = !0;
    }
    else {
      if (r.elementShared || r.dashedIdent || r.isAuto) return -1;
      i++;
      const c = t[i];
      if (!c) return -1;
      const p = N(B(x([c]), e, n));
      if (p === -1 || !g(p.value) || p.value[4].value < 0 || p.value[4].value > 1) return -1;
      r.fixed = Math.max(0, Math.min(p.value[4].value, 1 - 1e-9));
    }
    else {
      if (r.fixed !== -1) return -1;
      r.elementShared = !0;
    }
  }
  return -1;
}
function x(t) {
  return new F([a.Function, "calc(", -1, -1, { value: "calc" }], [a.CloseParen, ")", -1, -1, void 0], t);
}
function $n(t, e) {
  return new F([a.Function, "max(", -1, -1, { value: "max" }], [a.CloseParen, ")", -1, -1, void 0], [t, new d([a.Comma, ",", -1, -1, void 0]), e]);
}
function qn(t) {
  if (t === -1) return -1;
  if (le(t)) return t;
  const e = t.value;
  return b(e) && Number.isNaN(e[4].value) ? g(e) ? new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, "NaN", e[2], e[3], { value: "NaN" }])]) : y(e) ? new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, "NaN", e[2], e[3], { value: "NaN" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Delim, "*", e[2], e[3], { value: "*" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Dimension, "1" + e[4].unit, e[2], e[3], { value: 1, type: l.Integer, unit: e[4].unit }])]) : P(e) ? new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, "NaN", e[2], e[3], { value: "NaN" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Delim, "*", e[2], e[3], { value: "*" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Percentage, "1%", e[2], e[3], { value: 1 }])]) : -1 : t;
}
function zn(t) {
  if (t === -1) return -1;
  if (le(t)) return t;
  const e = t.value;
  if (!b(e) || Number.isFinite(e[4].value) || Number.isNaN(e[4].value)) return t;
  let n = "";
  return Number.NEGATIVE_INFINITY === e[4].value && (n = "-"), g(e) ? new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, n + "infinity", e[2], e[3], { value: n + "infinity" }])]) : y(e) ? new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, n + "infinity", e[2], e[3], { value: n + "infinity" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Delim, "*", e[2], e[3], { value: "*" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Dimension, "1" + e[4].unit, e[2], e[3], { value: 1, type: l.Integer, unit: e[4].unit }])]) : new F([a.Function, "calc(", e[2], e[3], { value: "calc" }], [a.CloseParen, ")", e[2], e[3], void 0], [new d([a.Ident, n + "infinity", e[2], e[3], { value: n + "infinity" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Delim, "*", e[2], e[3], { value: "*" }]), new T([[a.Whitespace, " ", e[2], e[3], void 0]]), new d([a.Percentage, "1%", e[2], e[3], { value: 1 }])]);
}
function Vn(t) {
  if (t === -1) return -1;
  if (le(t)) return t;
  const e = t.value;
  return b(e) && Object.is(-0, e[4].value) && (e[1] === "-0" || (P(e) ? e[1] = "-0%" : y(e) ? e[1] = "-0" + e[4].unit : e[1] = "-0")), t;
}
function Hn(t, e = 13) {
  if (t === -1) return -1;
  if (e <= 0 || le(t)) return t;
  const n = t.value;
  if (!b(n) || Number.isInteger(n[4].value)) return t;
  const r = Number(n[4].value.toFixed(e)).toString();
  return g(n) ? n[1] = r : P(n) ? n[1] = r + "%" : y(n) && (n[1] = r + n[4].unit), t;
}
function jn(t, e) {
  let n = t;
  return n = Hn(n, e == null ? void 0 : e.precision), n = Vn(n), n = qn(n), n = zn(n), n;
}
function Gn(t) {
  return /* @__PURE__ */ new Map();
}
function Jn(t, e) {
  return Yn(Vt(wt({ css: t }), {}), e).map((n) => n.map((r) => j(...r.tokens())).join("")).join(",");
}
function Yn(t, e) {
  const n = Gn();
  return Gt(t, (r) => {
    if (!le(r)) return;
    const o = Le.get(r.getName().toLowerCase());
    if (!o) return;
    const i = jn(N(o(r, n, {})), e);
    return i !== -1 ? i : void 0;
  });
}
new Set(Le.keys());
const q = (t) => {
  const e = `${t}`, n = parseFloat(e);
  let r = "unsupported";
  const o = e.match(/px|rem|em/);
  return o && (r = o[0]), n === 0 && r === "unsupported" && (r = "zero"), { number: n, unit: r };
}, He = (t) => {
  const e = {};
  if (typeof t == "string")
    e.fontSize = q(t);
  else if (Array.isArray(t)) {
    if (e.fontSize = q(t[0]), typeof t[1] == "string")
      e.lineHeight = q(t[1]);
    else if (typeof t[1] == "object") {
      if ("lineHeight" in t[1]) {
        let n = t[1].lineHeight;
        typeof n == "string" && n.includes("calc") && (n = Jn(n));
        const r = q(n);
        r.unit === "unsupported" ? e.lineHeight = {
          number: n * e.fontSize.number,
          unit: e.fontSize.unit
        } : e.lineHeight = r;
      }
      "letterSpacing" in t[1] && (e.letterSpacing = q(t[1].letterSpacing));
    }
  }
  return e;
}, Te = (t, e, n, r = null) => t.number === e.number ? (fe.error(
  `Same value for start an end${r ? ` (${r})` : ""}: "clamp-[${n}]".`
), null) : t.unit !== e.unit && t.unit !== "zero" && e.unit !== "zero" ? (fe.error(
  `Units need to match${r ? ` (${r})` : ""}: "clamp-[${n}]"  ${t.unit} !== ${e.unit}.`
), null) : t.unit === "unsupported" || e.unit === "unsupported" ? (fe.error(
  `Only px, rem and em units are supported${r ? ` (${r})` : ""}: "clamp-[${n}]".`
), null) : !0, je = (t, e, n = { number: 23.4375, unit: "rem" }, r = { number: 90, unit: "rem" }, o = !1) => {
  const i = t.unit === "zero" ? e.unit : t.unit, s = i === "px";
  let u = t.number, c = e.number, p = !1, f = n.number, v = r.number;
  n.unit !== "px" && s && (f = n.number * 16), n.unit === "px" && !s && (f = n.number / 16), r.unit !== "px" && s && (v = r.number * 16), r.unit === "px" && !s && (v = r.number / 16), c < u && u < 0 && c < 0 ? (u = Math.abs(u), c = Math.abs(c), p = !0) : c < u && u > 0 && c > 0 ? (u = u * -1, c = c * -1, p = !0) : c < u && (u = Math.abs(u) * -1, c = Math.abs(c), p = !0);
  const S = (c - u) / (v - f), E = `${(u - f * S).toFixed(6)}${i} + ${(100 * S).toFixed(6)}${o ? "cqw" : "vw"}`, I = `clamp(${u}${i}, ${E}, ${c}${i})`;
  return p ? `calc(${I} * -1)` : I;
}, Zn = {
  minSize: "23.4375rem",
  maxSize: "90rem"
};
function Ge(t, e, n, r) {
  if (!t)
    return {
      ...q(e),
      isContainer: !1
    };
  const o = t.startsWith("@"), i = o ? t.slice(1) : t, s = o ? r[i] || i : n[i] || i;
  return {
    ...q(s),
    isContainer: o
  };
}
const Xn = ct.withOptions(function(t = {}) {
  const e = { ...Zn, ...t };
  return function({ matchUtilities: n, theme: r, config: o }) {
    n(
      {
        clamp: (i) => {
          const s = i.split(",");
          if (s.length < 3)
            return fe.error(
              `The clamp utility requires at least 3 arguments: "clamp-[${i}]".`
            ), {};
          const u = r("screens"), c = r("containers"), p = Ge(
            s[3],
            e.minSize,
            u,
            c
          ), f = Ge(
            s[4],
            e.maxSize,
            u,
            c
          );
          if (!Te(p, f, i))
            return {};
          const v = p.isContainer, S = lt(s[0]);
          if (!S)
            return fe.error(
              `Property "${s[0]}" is not supported: "clamp-[${i}]".`
            ), {};
          const { key: E, props: I, type: h } = S;
          if (h === "fontSize") {
            const k = He(
              o().theme[E][s[1]] || s[1]
            ), W = He(
              o().theme[E][s[2]] || s[2]
            ), pe = {};
            return Object.keys(k).forEach((A) => {
              if (A in W) {
                if ((A === "letterSpacing" || A === "lineHeight") && k[A].number === W[A].number && k[A].unit === W[A].unit)
                  pe[A] = `${k[A].number}${k[A].unit}`;
                else if (Te(k[A], W[A], i, A)) {
                  const at = je(
                    k[A],
                    W[A],
                    p,
                    f,
                    v
                  );
                  pe[A] = at;
                }
              }
            }), pe;
          }
          let L = q(o().theme[E][s[1]] || s[1]), V = q(o().theme[E][s[2]] || s[2]);
          if (h === "spacing") {
            const k = q(
              typeof r("spacing") == "string" ? r("spacing") : r("spacing.1")
            ), W = /^-?\d*\.?\d+$/.test(s[1]), pe = /^-?\d*\.?\d+$/.test(s[2]);
            W && (L = {
              number: k.number * parseFloat(s[1]),
              unit: k.unit
            }), pe && (V = {
              number: k.number * parseFloat(s[2]),
              unit: k.unit
            });
          }
          if (!Te(L, V, i))
            return {};
          const de = je(L, V, p, f, v);
          return I.reduce((k, W) => (typeof W == "string" ? k[W] = de : k = { ...k, ...W }, k), {});
        }
      },
      { values: r("clamp") },
      {
        supportsNegativeValues: !1,
        modifiers: {
          pattern: /[\w-]+(?:,[\w-]+){2}/
          // Matches "text,lg,3xl" format
        }
      }
    );
  };
});
export {
  Xn as default
};
//# sourceMappingURL=index.js.map
